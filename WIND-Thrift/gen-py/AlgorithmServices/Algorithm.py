#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def definePTU(self, systemDefinition):
        """
        Defines what components and algorithms the PTU has available for subscribing to.

        This function MUST be called every time the PTU changes (i.e. a new algorithm registers with the PTU)

        Returns EITHER a list of components that the algorithm would like to subscribe to OR an empty list.
         -If an empty list is returned, then the algorithm subscribes to all data in the system.
         -If this function is called again by the PTU then the algorithm MUST return a new
          list that replaces the previous subscriptions (note this is not additive!)
         -Algorithms MAY subscribe to other algorithms.  Algorithms will receive the output from
          the algorithm that is subscribed to in the next payload.  Thus circular dependencies
          do not pose an issue.

        Parameters:
         - systemDefinition
        """
        pass

    def getAlgorithmDefinition(self):
        """
        Get the capabilities of the algorithm based on the provided hardware.

        The algorithm definition is produced in response to definePTU and will produce an empty list
        if the PTU is not defined.  The algorithm definition shall only change when the PTU is redefined.
        There is one algorithm definition entry for each data product that is produced by the algorithm.
        """
        pass

    def getAlgorithmConfiguration(self):
        """
        Gets how the algorithms are configured, such as background times, etc...

        Returns current algorithm configurations
        """
        pass

    def setAlgorithmConfiguration(self, configuration):
        """
        Sets algorithm configuration options.

        Returns updated algorithm configuration

        Parameters:
         - configuration
        """
        pass

    def updateAlgorithm(self, systemData):
        """
        Gets called every 100 ms to update the algorithm on the latest data.

        The algorithm MUST respond with a systemData packet every 100 ms, but the list may be empty if there are no computed results.

        Parameters:
         - systemData
        """
        pass

    def sendCommand(self, command):
        """
        Gives the PTU (and thus the PTU UI and CVRS) the ability to send a command to the algorithm
        (such as reset background).

        MAY return either the command's response or an empty string

        Parameters:
         - command
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def definePTU(self, systemDefinition):
        """
        Defines what components and algorithms the PTU has available for subscribing to.

        This function MUST be called every time the PTU changes (i.e. a new algorithm registers with the PTU)

        Returns EITHER a list of components that the algorithm would like to subscribe to OR an empty list.
         -If an empty list is returned, then the algorithm subscribes to all data in the system.
         -If this function is called again by the PTU then the algorithm MUST return a new
          list that replaces the previous subscriptions (note this is not additive!)
         -Algorithms MAY subscribe to other algorithms.  Algorithms will receive the output from
          the algorithm that is subscribed to in the next payload.  Thus circular dependencies
          do not pose an issue.

        Parameters:
         - systemDefinition
        """
        self.send_definePTU(systemDefinition)
        return self.recv_definePTU()

    def send_definePTU(self, systemDefinition):
        self._oprot.writeMessageBegin('definePTU', TMessageType.CALL, self._seqid)
        args = definePTU_args()
        args.systemDefinition = systemDefinition
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_definePTU(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = definePTU_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "definePTU failed: unknown result")

    def getAlgorithmDefinition(self):
        """
        Get the capabilities of the algorithm based on the provided hardware.

        The algorithm definition is produced in response to definePTU and will produce an empty list
        if the PTU is not defined.  The algorithm definition shall only change when the PTU is redefined.
        There is one algorithm definition entry for each data product that is produced by the algorithm.
        """
        self.send_getAlgorithmDefinition()
        return self.recv_getAlgorithmDefinition()

    def send_getAlgorithmDefinition(self):
        self._oprot.writeMessageBegin('getAlgorithmDefinition', TMessageType.CALL, self._seqid)
        args = getAlgorithmDefinition_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAlgorithmDefinition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAlgorithmDefinition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAlgorithmDefinition failed: unknown result")

    def getAlgorithmConfiguration(self):
        """
        Gets how the algorithms are configured, such as background times, etc...

        Returns current algorithm configurations
        """
        self.send_getAlgorithmConfiguration()
        return self.recv_getAlgorithmConfiguration()

    def send_getAlgorithmConfiguration(self):
        self._oprot.writeMessageBegin('getAlgorithmConfiguration', TMessageType.CALL, self._seqid)
        args = getAlgorithmConfiguration_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAlgorithmConfiguration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAlgorithmConfiguration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAlgorithmConfiguration failed: unknown result")

    def setAlgorithmConfiguration(self, configuration):
        """
        Sets algorithm configuration options.

        Returns updated algorithm configuration

        Parameters:
         - configuration
        """
        self.send_setAlgorithmConfiguration(configuration)
        return self.recv_setAlgorithmConfiguration()

    def send_setAlgorithmConfiguration(self, configuration):
        self._oprot.writeMessageBegin('setAlgorithmConfiguration', TMessageType.CALL, self._seqid)
        args = setAlgorithmConfiguration_args()
        args.configuration = configuration
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setAlgorithmConfiguration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setAlgorithmConfiguration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setAlgorithmConfiguration failed: unknown result")

    def updateAlgorithm(self, systemData):
        """
        Gets called every 100 ms to update the algorithm on the latest data.

        The algorithm MUST respond with a systemData packet every 100 ms, but the list may be empty if there are no computed results.

        Parameters:
         - systemData
        """
        self.send_updateAlgorithm(systemData)
        return self.recv_updateAlgorithm()

    def send_updateAlgorithm(self, systemData):
        self._oprot.writeMessageBegin('updateAlgorithm', TMessageType.CALL, self._seqid)
        args = updateAlgorithm_args()
        args.systemData = systemData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateAlgorithm(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateAlgorithm_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateAlgorithm failed: unknown result")

    def sendCommand(self, command):
        """
        Gives the PTU (and thus the PTU UI and CVRS) the ability to send a command to the algorithm
        (such as reset background).

        MAY return either the command's response or an empty string

        Parameters:
         - command
        """
        self.send_sendCommand(command)
        return self.recv_sendCommand()

    def send_sendCommand(self, command):
        self._oprot.writeMessageBegin('sendCommand', TMessageType.CALL, self._seqid)
        args = sendCommand_args()
        args.command = command
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_sendCommand(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = sendCommand_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "sendCommand failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["definePTU"] = Processor.process_definePTU
        self._processMap["getAlgorithmDefinition"] = Processor.process_getAlgorithmDefinition
        self._processMap["getAlgorithmConfiguration"] = Processor.process_getAlgorithmConfiguration
        self._processMap["setAlgorithmConfiguration"] = Processor.process_setAlgorithmConfiguration
        self._processMap["updateAlgorithm"] = Processor.process_updateAlgorithm
        self._processMap["sendCommand"] = Processor.process_sendCommand

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_definePTU(self, seqid, iprot, oprot):
        args = definePTU_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = definePTU_result()
        try:
            result.success = self._handler.definePTU(args.systemDefinition)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("definePTU", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAlgorithmDefinition(self, seqid, iprot, oprot):
        args = getAlgorithmDefinition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAlgorithmDefinition_result()
        try:
            result.success = self._handler.getAlgorithmDefinition()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAlgorithmDefinition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAlgorithmConfiguration(self, seqid, iprot, oprot):
        args = getAlgorithmConfiguration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAlgorithmConfiguration_result()
        try:
            result.success = self._handler.getAlgorithmConfiguration()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAlgorithmConfiguration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setAlgorithmConfiguration(self, seqid, iprot, oprot):
        args = setAlgorithmConfiguration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setAlgorithmConfiguration_result()
        try:
            result.success = self._handler.setAlgorithmConfiguration(args.configuration)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Exceptions.ttypes.UpdateError as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setAlgorithmConfiguration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateAlgorithm(self, seqid, iprot, oprot):
        args = updateAlgorithm_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateAlgorithm_result()
        try:
            result.success = self._handler.updateAlgorithm(args.systemData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateAlgorithm", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_sendCommand(self, seqid, iprot, oprot):
        args = sendCommand_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sendCommand_result()
        try:
            result.success = self._handler.sendCommand(args.command)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("sendCommand", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class definePTU_args(object):
    """
    Attributes:
     - systemDefinition
    """


    def __init__(self, systemDefinition=None,):
        self.systemDefinition = systemDefinition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.systemDefinition = PTUPayload.ttypes.SystemDefinition()
                    self.systemDefinition.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('definePTU_args')
        if self.systemDefinition is not None:
            oprot.writeFieldBegin('systemDefinition', TType.STRUCT, 1)
            self.systemDefinition.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(definePTU_args)
definePTU_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'systemDefinition', [PTUPayload.ttypes.SystemDefinition, None], None, ),  # 1
)


class definePTU_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = UUID.ttypes.UUID()
                        _elem5.read(iprot)
                        self.success.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('definePTU_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter6 in self.success:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(definePTU_result)
definePTU_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [UUID.ttypes.UUID, None], False), None, ),  # 0
)


class getAlgorithmDefinition_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAlgorithmDefinition_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAlgorithmDefinition_args)
getAlgorithmDefinition_args.thrift_spec = (
)


class getAlgorithmDefinition_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = AlgorithmPayload.ttypes.AlgorithmDefinition()
                        _elem12.read(iprot)
                        self.success.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAlgorithmDefinition_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter13 in self.success:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAlgorithmDefinition_result)
getAlgorithmDefinition_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [AlgorithmPayload.ttypes.AlgorithmDefinition, None], False), None, ),  # 0
)


class getAlgorithmConfiguration_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAlgorithmConfiguration_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAlgorithmConfiguration_args)
getAlgorithmConfiguration_args.thrift_spec = (
)


class getAlgorithmConfiguration_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = AlgorithmPayload.ttypes.AlgorithmConfiguration()
                        _elem19.read(iprot)
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAlgorithmConfiguration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter20 in self.success:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAlgorithmConfiguration_result)
getAlgorithmConfiguration_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [AlgorithmPayload.ttypes.AlgorithmConfiguration, None], False), None, ),  # 0
)


class setAlgorithmConfiguration_args(object):
    """
    Attributes:
     - configuration
    """


    def __init__(self, configuration=None,):
        self.configuration = configuration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.configuration = AlgorithmPayload.ttypes.AlgorithmConfiguration()
                    self.configuration.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setAlgorithmConfiguration_args')
        if self.configuration is not None:
            oprot.writeFieldBegin('configuration', TType.STRUCT, 1)
            self.configuration.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setAlgorithmConfiguration_args)
setAlgorithmConfiguration_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'configuration', [AlgorithmPayload.ttypes.AlgorithmConfiguration, None], None, ),  # 1
)


class setAlgorithmConfiguration_result(object):
    """
    Attributes:
     - success
     - error
    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AlgorithmPayload.ttypes.AlgorithmConfiguration()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = Exceptions.ttypes.UpdateError()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setAlgorithmConfiguration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setAlgorithmConfiguration_result)
setAlgorithmConfiguration_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [AlgorithmPayload.ttypes.AlgorithmConfiguration, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [Exceptions.ttypes.UpdateError, None], None, ),  # 1
)


class updateAlgorithm_args(object):
    """
    Attributes:
     - systemData
    """


    def __init__(self, systemData=None,):
        self.systemData = systemData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.systemData = PTUPayload.ttypes.DataPayload()
                    self.systemData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateAlgorithm_args')
        if self.systemData is not None:
            oprot.writeFieldBegin('systemData', TType.STRUCT, 1)
            self.systemData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateAlgorithm_args)
updateAlgorithm_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'systemData', [PTUPayload.ttypes.DataPayload, None], None, ),  # 1
)


class updateAlgorithm_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = AlgorithmPayload.ttypes.AlgorithmData()
                        _elem26.read(iprot)
                        self.success.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateAlgorithm_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter27 in self.success:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateAlgorithm_result)
updateAlgorithm_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [AlgorithmPayload.ttypes.AlgorithmData, None], False), None, ),  # 0
)


class sendCommand_args(object):
    """
    Attributes:
     - command
    """


    def __init__(self, command=None,):
        self.command = command

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.command = Command.ttypes.Command()
                    self.command.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sendCommand_args')
        if self.command is not None:
            oprot.writeFieldBegin('command', TType.STRUCT, 1)
            self.command.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sendCommand_args)
sendCommand_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'command', [Command.ttypes.Command, None], None, ),  # 1
)


class sendCommand_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('sendCommand_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(sendCommand_result)
sendCommand_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)
fix_spec(all_structs)
del all_structs

