#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import Common.ttypes

from thrift.transport import TTransport
all_structs = []


class DirectionalityConfiguration(object):
    """
    Directionalitys are produced by the Algorithm and returned to the
    DAQ for the UI and archiving.

    Attributes:
     - integrationTime: The time of the rolling window used in computing the
    directionality result.
    """


    def __init__(self, integrationTime=None,):
        self.integrationTime = integrationTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.integrationTime = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DirectionalityConfiguration')
        if self.integrationTime is not None:
            oprot.writeFieldBegin('integrationTime', TType.DOUBLE, 1)
            oprot.writeDouble(self.integrationTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DirectionalityDefinition(object):
    """
    Attributes:
     - initialConfiguration
     - type: Type of directionality result being reported.
    """


    def __init__(self, initialConfiguration=None, type=None,):
        self.initialConfiguration = initialConfiguration
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.initialConfiguration = DirectionalityConfiguration()
                    self.initialConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DirectionalityDefinition')
        if self.initialConfiguration is not None:
            oprot.writeFieldBegin('initialConfiguration', TType.STRUCT, 1)
            self.initialConfiguration.write(oprot)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DirectionalityResult(object):
    """
    Directionality result indicating the direction to a source
    relative to the current position and orientation of the system.
    This is to support a compass like display for the user such as
    augmented reality.

    Directionality results must be reported incrementally on regular
    intervals while a source is in the field of view as defined in
    the algorithm payload.

    The bearing and elevation shall apply the current time interval
    reported. The distance may use information from previous positions
    and thus may use a larger time window.  The longer time window for
    location will not be reported in the AlgorithmResult.

    Not every result will be able to provide elevation and distance.
    They will be provided when available, and the same event may
    produce multiple results for different time periods in which
    direction and elevation provided for only some of the results.

    An algorithm shall produce no more than one directionality per
    event id per detector type per time period.  Multiple sources
    can be reported in the same time with different event ids.

    Directionality results must be associated with an event id.

    Attributes:
     - bearing: Bearing to the source relative to the current orientation of the
    detector system in degrees.
     - bearingUncertainty: Uncertainty in terms of one standard deviations.
     - distance: Distance in meters to the estimated source position relative
    to the current location of the system if it can be determined.
     - distanceUncertainty: Uncertainty in terms of one standard deviations.
     - elevation: Elevation of the source in degrees relative to level
    along the bearing if it can be determined.  A positive elevation
    indicates a source above the center of the detector system
     while a negative elevation indicated a source below.
     - elevationUncertainty: Uncertainty in terms of one standard deviations.
    """


    def __init__(self, bearing=None, bearingUncertainty=None, distance=None, distanceUncertainty=None, elevation=None, elevationUncertainty=None,):
        self.bearing = bearing
        self.bearingUncertainty = bearingUncertainty
        self.distance = distance
        self.distanceUncertainty = distanceUncertainty
        self.elevation = elevation
        self.elevationUncertainty = elevationUncertainty

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.bearing = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.bearingUncertainty = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.distance = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.distanceUncertainty = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.elevation = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.elevationUncertainty = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DirectionalityResult')
        if self.bearing is not None:
            oprot.writeFieldBegin('bearing', TType.DOUBLE, 1)
            oprot.writeDouble(self.bearing)
            oprot.writeFieldEnd()
        if self.bearingUncertainty is not None:
            oprot.writeFieldBegin('bearingUncertainty', TType.DOUBLE, 2)
            oprot.writeDouble(self.bearingUncertainty)
            oprot.writeFieldEnd()
        if self.distance is not None:
            oprot.writeFieldBegin('distance', TType.DOUBLE, 3)
            oprot.writeDouble(self.distance)
            oprot.writeFieldEnd()
        if self.distanceUncertainty is not None:
            oprot.writeFieldBegin('distanceUncertainty', TType.DOUBLE, 4)
            oprot.writeDouble(self.distanceUncertainty)
            oprot.writeFieldEnd()
        if self.elevation is not None:
            oprot.writeFieldBegin('elevation', TType.DOUBLE, 5)
            oprot.writeDouble(self.elevation)
            oprot.writeFieldEnd()
        if self.elevationUncertainty is not None:
            oprot.writeFieldBegin('elevationUncertainty', TType.DOUBLE, 6)
            oprot.writeDouble(self.elevationUncertainty)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DirectionalityConfiguration)
DirectionalityConfiguration.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'integrationTime', None, None, ),  # 1
)
all_structs.append(DirectionalityDefinition)
DirectionalityDefinition.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'initialConfiguration', [DirectionalityConfiguration, None], None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
)
all_structs.append(DirectionalityResult)
DirectionalityResult.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'bearing', None, None, ),  # 1
    (2, TType.DOUBLE, 'bearingUncertainty', None, None, ),  # 2
    (3, TType.DOUBLE, 'distance', None, None, ),  # 3
    (4, TType.DOUBLE, 'distanceUncertainty', None, None, ),  # 4
    (5, TType.DOUBLE, 'elevation', None, None, ),  # 5
    (6, TType.DOUBLE, 'elevationUncertainty', None, None, ),  # 6
)
fix_spec(all_structs)
del all_structs
