#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import Identification.ttypes
import Localization.ttypes
import Directionality.ttypes
import Detection.ttypes
import Health.ttypes
import UUID.ttypes
import ProcessedImage.ttypes
import Common.ttypes
import Component.ttypes
import NavigationSensor.ttypes

from thrift.transport import TTransport
all_structs = []


class LogSeverity(object):
    """
    Indication of how to interpret log messages.  Severity of WARNING
    and above indicate a fault that may adversely affect the
    algorithm output.
    """
    FATAL = 0
    ERROR = 1
    WARNING = 2
    INFO = 3
    RESOLVED = 4

    _VALUES_TO_NAMES = {
        0: "FATAL",
        1: "ERROR",
        2: "WARNING",
        3: "INFO",
        4: "RESOLVED",
    }

    _NAMES_TO_VALUES = {
        "FATAL": 0,
        "ERROR": 1,
        "WARNING": 2,
        "INFO": 3,
        "RESOLVED": 4,
    }


class AlgorithmServerState(object):
    """
    Algorithm Server state
    Note that the client (PTU or CVRS) should have a reasonable timeout on waiting for
    algorithm results.
    """
    Idle = 1
    Busy = 2

    _VALUES_TO_NAMES = {
        1: "Idle",
        2: "Busy",
    }

    _NAMES_TO_VALUES = {
        "Idle": 1,
        "Busy": 2,
    }


class AlgorithmLog(object):
    """
    Data structure to push messages to the UI and archiver on the
    state of an algorithm.

    These should be used sparingly to indicate details on the state
    of health of an algorithm.  Log messages are expected to be issued
    after receiving the system definition, a new configuration, or
    when there is a significant change that adversely affects
    the results of the algorithm.

    Attributes:
     - referenceId: A unique id associated with this fault either issued
    as a fixed value for the same fault used consistently
    to report the same error condition or a unique id
    for a dynamically issued fault.

    Faults are assumed to be stateful.  Thus if a ERROR is
    issued, the error state is assumed to persist until such
    time as it is cleared.  To indicate that a condition is
    no longer present an END severity is issued withe same
    referenceId.

    There is no requirement terminate a condition, but the data
    will be interpreted as though the condition is persistent.
     - severity: Severity of the fault.
     - message: Human readable message describing the fault.  All log messages
    except for those of type END shall have a message content.
     - reference: Component id of the sensor which caused the fault (if applicable)
    """


    def __init__(self, referenceId=None, severity=None, message=None, reference=None,):
        self.referenceId = referenceId
        self.severity = severity
        self.message = message
        self.reference = reference

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.referenceId = UUID.ttypes.UUID()
                    self.referenceId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.severity = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.reference = UUID.ttypes.UUID()
                    self.reference.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AlgorithmLog')
        if self.referenceId is not None:
            oprot.writeFieldBegin('referenceId', TType.STRUCT, 1)
            self.referenceId.write(oprot)
            oprot.writeFieldEnd()
        if self.severity is not None:
            oprot.writeFieldBegin('severity', TType.I32, 2)
            oprot.writeI32(self.severity)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 3)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.reference is not None:
            oprot.writeFieldBegin('reference', TType.STRUCT, 4)
            self.reference.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AlgorithmConfigurationUnion(object):
    """
    Attributes:
     - detectionConfiguration
     - identificationConfiguration
     - localizationConfiguration
     - directionalityConfiguration
     - processedImageConfiguration
    """


    def __init__(self, detectionConfiguration=None, identificationConfiguration=None, localizationConfiguration=None, directionalityConfiguration=None, processedImageConfiguration=None,):
        self.detectionConfiguration = detectionConfiguration
        self.identificationConfiguration = identificationConfiguration
        self.localizationConfiguration = localizationConfiguration
        self.directionalityConfiguration = directionalityConfiguration
        self.processedImageConfiguration = processedImageConfiguration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.detectionConfiguration = Detection.ttypes.DetectionConfiguration()
                    self.detectionConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.identificationConfiguration = Identification.ttypes.IdentificationConfiguration()
                    self.identificationConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.localizationConfiguration = Localization.ttypes.LocalizationConfiguration()
                    self.localizationConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.directionalityConfiguration = Directionality.ttypes.DirectionalityConfiguration()
                    self.directionalityConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.processedImageConfiguration = ProcessedImage.ttypes.ProcessedImageConfiguration()
                    self.processedImageConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AlgorithmConfigurationUnion')
        if self.detectionConfiguration is not None:
            oprot.writeFieldBegin('detectionConfiguration', TType.STRUCT, 1)
            self.detectionConfiguration.write(oprot)
            oprot.writeFieldEnd()
        if self.identificationConfiguration is not None:
            oprot.writeFieldBegin('identificationConfiguration', TType.STRUCT, 2)
            self.identificationConfiguration.write(oprot)
            oprot.writeFieldEnd()
        if self.localizationConfiguration is not None:
            oprot.writeFieldBegin('localizationConfiguration', TType.STRUCT, 3)
            self.localizationConfiguration.write(oprot)
            oprot.writeFieldEnd()
        if self.directionalityConfiguration is not None:
            oprot.writeFieldBegin('directionalityConfiguration', TType.STRUCT, 4)
            self.directionalityConfiguration.write(oprot)
            oprot.writeFieldEnd()
        if self.processedImageConfiguration is not None:
            oprot.writeFieldBegin('processedImageConfiguration', TType.STRUCT, 5)
            self.processedImageConfiguration.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AlgorithmConfiguration(object):
    """
    Defines algorithm settings that are changeable, but aren't data gathered by the sensor

    Attributes:
     - componentId: Used to match data, configuration, and definition.  Must be unique in the system.
     - contents: Polymorphic Data message
     - log: Messages produced in response to the last Configuration request.
    This will used be indict how the algorithm is interpreting
    the configuration change.

    This may contain any type of log message. Faults of ERROR or FATAL
    will indicate that the system is not functional under the current
    system configuration.  Faults of level WARNING indicate conditions
    that can be tolerated but may affect performance.  INFO is used
    to indicate any other applicable data.
    """


    def __init__(self, componentId=None, contents=None, log=None,):
        self.componentId = componentId
        self.contents = contents
        self.log = log

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.componentId = UUID.ttypes.UUID()
                    self.componentId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.contents = AlgorithmConfigurationUnion()
                    self.contents.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.log = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = AlgorithmLog()
                        _elem5.read(iprot)
                        self.log.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AlgorithmConfiguration')
        if self.componentId is not None:
            oprot.writeFieldBegin('componentId', TType.STRUCT, 1)
            self.componentId.write(oprot)
            oprot.writeFieldEnd()
        if self.contents is not None:
            oprot.writeFieldBegin('contents', TType.STRUCT, 2)
            self.contents.write(oprot)
            oprot.writeFieldEnd()
        if self.log is not None:
            oprot.writeFieldBegin('log', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.log))
            for iter6 in self.log:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AlgorithmDefinitionUnion(object):
    """
    Defines a specific product for an algorithm.

    The algorithm definition is produced in response to the PTU definition based on the capabilities of the
    algorithm given the specified hardware.  Algorithms can produce multiple different algorithm products
    and may produce multiple implementation of the same data product.

    Each algorithm product should have its own unique componentId within the system.
    That componentId will be used to differentiate if more than one data product of the
    same type is produced by the algorithm.

    Attributes:
     - detectionDefinition
     - identificationDefinition
     - localizationDefinition
     - directionalityDefinition
     - processedImageDefinition
     - navOutputDefinition
    """


    def __init__(self, detectionDefinition=None, identificationDefinition=None, localizationDefinition=None, directionalityDefinition=None, processedImageDefinition=None, navOutputDefinition=None,):
        self.detectionDefinition = detectionDefinition
        self.identificationDefinition = identificationDefinition
        self.localizationDefinition = localizationDefinition
        self.directionalityDefinition = directionalityDefinition
        self.processedImageDefinition = processedImageDefinition
        self.navOutputDefinition = navOutputDefinition

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.detectionDefinition = Detection.ttypes.DetectionDefinition()
                    self.detectionDefinition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.identificationDefinition = Identification.ttypes.IdentificationDefinition()
                    self.identificationDefinition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.localizationDefinition = Localization.ttypes.LocalizationDefinition()
                    self.localizationDefinition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.directionalityDefinition = Directionality.ttypes.DirectionalityDefinition()
                    self.directionalityDefinition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.processedImageDefinition = ProcessedImage.ttypes.ProcessedImageDefinition()
                    self.processedImageDefinition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.navOutputDefinition = NavigationSensor.ttypes.NavigationOutputDefinition()
                    self.navOutputDefinition.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AlgorithmDefinitionUnion')
        if self.detectionDefinition is not None:
            oprot.writeFieldBegin('detectionDefinition', TType.STRUCT, 1)
            self.detectionDefinition.write(oprot)
            oprot.writeFieldEnd()
        if self.identificationDefinition is not None:
            oprot.writeFieldBegin('identificationDefinition', TType.STRUCT, 2)
            self.identificationDefinition.write(oprot)
            oprot.writeFieldEnd()
        if self.localizationDefinition is not None:
            oprot.writeFieldBegin('localizationDefinition', TType.STRUCT, 3)
            self.localizationDefinition.write(oprot)
            oprot.writeFieldEnd()
        if self.directionalityDefinition is not None:
            oprot.writeFieldBegin('directionalityDefinition', TType.STRUCT, 4)
            self.directionalityDefinition.write(oprot)
            oprot.writeFieldEnd()
        if self.processedImageDefinition is not None:
            oprot.writeFieldBegin('processedImageDefinition', TType.STRUCT, 5)
            self.processedImageDefinition.write(oprot)
            oprot.writeFieldEnd()
        if self.navOutputDefinition is not None:
            oprot.writeFieldBegin('navOutputDefinition', TType.STRUCT, 6)
            self.navOutputDefinition.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AlgorithmDefinition(object):
    """
    Attributes:
     - component
     - contents: Polymorphic data type.
     - log: Messages produced in response to the last SystemDefinition.
    This will used be indict how the algorithm is interpreting
    the system.

    This may contain any type of log message. Faults of ERROR or FATAL
    will indicate that the system is not functional under the current
    system definition.  Faults of level WARNING indicate conditions
    that can be tolerated but may affect performance.  INFO is used
    to indicate any other applicable data.
    """


    def __init__(self, component=None, contents=None, log=None,):
        self.component = component
        self.contents = contents
        self.log = log

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.component = Component.ttypes.ComponentDefinition()
                    self.component.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.contents = AlgorithmDefinitionUnion()
                    self.contents.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.log = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = AlgorithmLog()
                        _elem12.read(iprot)
                        self.log.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AlgorithmDefinition')
        if self.component is not None:
            oprot.writeFieldBegin('component', TType.STRUCT, 1)
            self.component.write(oprot)
            oprot.writeFieldEnd()
        if self.contents is not None:
            oprot.writeFieldBegin('contents', TType.STRUCT, 5)
            self.contents.write(oprot)
            oprot.writeFieldEnd()
        if self.log is not None:
            oprot.writeFieldBegin('log', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.log))
            for iter13 in self.log:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AlgorithmDebug(object):
    """
    Algorithm debug result structure.  This should not be used for normal operation.

    Attributes:
     - debugData
    """


    def __init__(self, debugData=None,):
        self.debugData = debugData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.debugData = {}
                    (_ktype15, _vtype16, _size14) = iprot.readMapBegin()
                    for _i18 in range(_size14):
                        _key19 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val20 = iprot.readBinary()
                        self.debugData[_key19] = _val20
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AlgorithmDebug')
        if self.debugData is not None:
            oprot.writeFieldBegin('debugData', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.debugData))
            for kiter21, viter22 in self.debugData.items():
                oprot.writeString(kiter21.encode('utf-8') if sys.version_info[0] == 2 else kiter21)
                oprot.writeBinary(viter22)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AlgorithmUnion(object):
    """
    Individual data for an analysis result.

    This structure contains common header information related to all results and a union
    of different data types.  The data structure hold the results from any of the algorithm
    components.

    Each algorithm component may produce, at most, one report for each source in view.

    Algorithm components should produce, at most, one type of data.  These may be
    detection, localization, or identification.  If a particular algorithm
    component has more than one type of result, the result must have a separate component
    id and definition.  This allows the stream to be filtered based on the algorithm
    and data type.

    Each time a source is encountered, a new event id will be issued by the system.
    The event id must be random as specified in the UUID documentation.

    All algorithm products related to that source will have the same event id.
    Products associated with a source must use that event id until the source leaves
    the field of view.  For algorithms that are performing a post analysis of the output of
    another algorithm will use the same time range and event id.  More than one source
    may be in the field of view at a time.

    Each data product has different requirements with regard to association with events,
    timestamp reporting, and production periods.  These requirements include

     - Regular intervals - Each result should be produced on a regular interval. The start time
       and end time should reflect the earlier.

     - As-available - The result should be updated whenever there is sufficient
       information available to improve the result last reported.  As-available should
       produce a final result after the source leaves the field of view.

     - Incremental reporting - The result must should be for a specific period of time and
       must cover the range of measurements which were added since the last report.  Results
       should never cover the same range.  Prior information may have been incorporated in forming
       the report but should not reported in the time range.

     - Cumulative reporting - The result may cover a range of measurement which may include
       the previous time period.  The start and end time should cover the earliest and latest
       measurements that were incorporated. Not all measurements during that time interval
       may be been used in producing a result.  Cumulative reports may cover the same
       time range as previous reports if the previous data was still applicable.  If the
       previous conditions no longer applied, the start time should reflect the time the source
       was in those conditions,  i.e, if a source appears to be stationary the start time will
       cover the entire time the source was present and the end time will be revised with each
       sequential result.  If the source is mobile, the start time and the end time
       will be updated with each result such that the result covers the time period that source
       was at that location.


    Detection results should not be associated with an event as there may be more that one source in the
    field of view, i.e., AlgorithmData.eventId should not be set.
    Detection algorithms must produce a result whenever a source is in view.  Detection results must be
    produced at a regular intervals and incrementally. Detection algorithms must have an a configuration
    option to produce results even when a source is not present.  There should be no more that one detection result from a
    detection component for the same time range.

    Localization results must be associated with an event.  Localization should be as-available and
    cumulative.

    Identification results must be associated with an event. Identification
    results should be reported as-available and may be cumulative or incremental.

    ProcessedImage results may or may not be associated with an event. An algorithm may produce map or image overlays
    that are associated with an event to help localize a detected source. One can imagine, however, images being produced
    that simply lead to an improved map of an area.

    NavigationData PTU localization results should not be associated with an event. An algorithm may produce improved
    localization of a PTU that is useful even without source detection, localization, and identification occurring.


    Attributes:
     - detectionResult
     - identificationResult
     - localizationResult
     - directionalityResult
     - processedImageResult
     - ptuLocalizationResult
    """


    def __init__(self, detectionResult=None, identificationResult=None, localizationResult=None, directionalityResult=None, processedImageResult=None, ptuLocalizationResult=None,):
        self.detectionResult = detectionResult
        self.identificationResult = identificationResult
        self.localizationResult = localizationResult
        self.directionalityResult = directionalityResult
        self.processedImageResult = processedImageResult
        self.ptuLocalizationResult = ptuLocalizationResult

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.detectionResult = Detection.ttypes.DetectionResult()
                    self.detectionResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.identificationResult = Identification.ttypes.IdentificationResult()
                    self.identificationResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.localizationResult = Localization.ttypes.LocalizationResult()
                    self.localizationResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.directionalityResult = Directionality.ttypes.DirectionalityResult()
                    self.directionalityResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.processedImageResult = ProcessedImage.ttypes.ProcessedImageResult()
                    self.processedImageResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.ptuLocalizationResult = NavigationSensor.ttypes.NavigationData()
                    self.ptuLocalizationResult.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AlgorithmUnion')
        if self.detectionResult is not None:
            oprot.writeFieldBegin('detectionResult', TType.STRUCT, 1)
            self.detectionResult.write(oprot)
            oprot.writeFieldEnd()
        if self.identificationResult is not None:
            oprot.writeFieldBegin('identificationResult', TType.STRUCT, 2)
            self.identificationResult.write(oprot)
            oprot.writeFieldEnd()
        if self.localizationResult is not None:
            oprot.writeFieldBegin('localizationResult', TType.STRUCT, 3)
            self.localizationResult.write(oprot)
            oprot.writeFieldEnd()
        if self.directionalityResult is not None:
            oprot.writeFieldBegin('directionalityResult', TType.STRUCT, 4)
            self.directionalityResult.write(oprot)
            oprot.writeFieldEnd()
        if self.processedImageResult is not None:
            oprot.writeFieldBegin('processedImageResult', TType.STRUCT, 5)
            self.processedImageResult.write(oprot)
            oprot.writeFieldEnd()
        if self.ptuLocalizationResult is not None:
            oprot.writeFieldBegin('ptuLocalizationResult', TType.STRUCT, 6)
            self.ptuLocalizationResult.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AlgorithmData(object):
    """
    Attributes:
     - componentId: The algorithm that is reporting this result.
     - eventId: Identifier to link multiple analyses together for one source.

    This must be set for any algorithm results that are tied to a specified source encounter.
    The same event number should be reported during the time a source is visible.  If
    a second source is encountered while a source is visible, it should be associated with
    another event id.

    eventId should not be set for detection results
     - startTimeStamp: Time range of that this analysis covers
     - endTimeStamp
     - health
     - contents: Polymorphic Data message
     - debugResult: Debug result
     - serverState: Algorithm Server status
     - faults: Details on the state of the algorithm to indict a fault.

    Faults should be issued sparingly and are considered stateful.
    A state is assumed to presist until such time as the fault
    state is cleared with an END message. INFO type
    messages are not allowed in the AlgorithmData.
    """


    def __init__(self, componentId=None, eventId=None, startTimeStamp=None, endTimeStamp=None, health=None, contents=None, debugResult=None, serverState=None, faults=None,):
        self.componentId = componentId
        self.eventId = eventId
        self.startTimeStamp = startTimeStamp
        self.endTimeStamp = endTimeStamp
        self.health = health
        self.contents = contents
        self.debugResult = debugResult
        self.serverState = serverState
        self.faults = faults

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.componentId = UUID.ttypes.UUID()
                    self.componentId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.eventId = UUID.ttypes.UUID()
                    self.eventId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startTimeStamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endTimeStamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.health = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.contents = AlgorithmUnion()
                    self.contents.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.debugResult = AlgorithmDebug()
                    self.debugResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.serverState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.faults = []
                    (_etype26, _size23) = iprot.readListBegin()
                    for _i27 in range(_size23):
                        _elem28 = AlgorithmLog()
                        _elem28.read(iprot)
                        self.faults.append(_elem28)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AlgorithmData')
        if self.componentId is not None:
            oprot.writeFieldBegin('componentId', TType.STRUCT, 1)
            self.componentId.write(oprot)
            oprot.writeFieldEnd()
        if self.eventId is not None:
            oprot.writeFieldBegin('eventId', TType.STRUCT, 2)
            self.eventId.write(oprot)
            oprot.writeFieldEnd()
        if self.startTimeStamp is not None:
            oprot.writeFieldBegin('startTimeStamp', TType.I64, 3)
            oprot.writeI64(self.startTimeStamp)
            oprot.writeFieldEnd()
        if self.endTimeStamp is not None:
            oprot.writeFieldBegin('endTimeStamp', TType.I64, 4)
            oprot.writeI64(self.endTimeStamp)
            oprot.writeFieldEnd()
        if self.health is not None:
            oprot.writeFieldBegin('health', TType.I32, 5)
            oprot.writeI32(self.health)
            oprot.writeFieldEnd()
        if self.contents is not None:
            oprot.writeFieldBegin('contents', TType.STRUCT, 6)
            self.contents.write(oprot)
            oprot.writeFieldEnd()
        if self.debugResult is not None:
            oprot.writeFieldBegin('debugResult', TType.STRUCT, 7)
            self.debugResult.write(oprot)
            oprot.writeFieldEnd()
        if self.serverState is not None:
            oprot.writeFieldBegin('serverState', TType.I32, 8)
            oprot.writeI32(self.serverState)
            oprot.writeFieldEnd()
        if self.faults is not None:
            oprot.writeFieldBegin('faults', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.faults))
            for iter29 in self.faults:
                iter29.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(AlgorithmLog)
AlgorithmLog.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'referenceId', [UUID.ttypes.UUID, None], None, ),  # 1
    (2, TType.I32, 'severity', None, None, ),  # 2
    (3, TType.STRING, 'message', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'reference', [UUID.ttypes.UUID, None], None, ),  # 4
)
all_structs.append(AlgorithmConfigurationUnion)
AlgorithmConfigurationUnion.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'detectionConfiguration', [Detection.ttypes.DetectionConfiguration, None], None, ),  # 1
    (2, TType.STRUCT, 'identificationConfiguration', [Identification.ttypes.IdentificationConfiguration, None], None, ),  # 2
    (3, TType.STRUCT, 'localizationConfiguration', [Localization.ttypes.LocalizationConfiguration, None], None, ),  # 3
    (4, TType.STRUCT, 'directionalityConfiguration', [Directionality.ttypes.DirectionalityConfiguration, None], None, ),  # 4
    (5, TType.STRUCT, 'processedImageConfiguration', [ProcessedImage.ttypes.ProcessedImageConfiguration, None], None, ),  # 5
)
all_structs.append(AlgorithmConfiguration)
AlgorithmConfiguration.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'componentId', [UUID.ttypes.UUID, None], None, ),  # 1
    (2, TType.STRUCT, 'contents', [AlgorithmConfigurationUnion, None], None, ),  # 2
    (3, TType.LIST, 'log', (TType.STRUCT, [AlgorithmLog, None], False), None, ),  # 3
)
all_structs.append(AlgorithmDefinitionUnion)
AlgorithmDefinitionUnion.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'detectionDefinition', [Detection.ttypes.DetectionDefinition, None], None, ),  # 1
    (2, TType.STRUCT, 'identificationDefinition', [Identification.ttypes.IdentificationDefinition, None], None, ),  # 2
    (3, TType.STRUCT, 'localizationDefinition', [Localization.ttypes.LocalizationDefinition, None], None, ),  # 3
    (4, TType.STRUCT, 'directionalityDefinition', [Directionality.ttypes.DirectionalityDefinition, None], None, ),  # 4
    (5, TType.STRUCT, 'processedImageDefinition', [ProcessedImage.ttypes.ProcessedImageDefinition, None], None, ),  # 5
    (6, TType.STRUCT, 'navOutputDefinition', [NavigationSensor.ttypes.NavigationOutputDefinition, None], None, ),  # 6
)
all_structs.append(AlgorithmDefinition)
AlgorithmDefinition.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'component', [Component.ttypes.ComponentDefinition, None], None, ),  # 1
    None,  # 2
    None,  # 3
    None,  # 4
    (5, TType.STRUCT, 'contents', [AlgorithmDefinitionUnion, None], None, ),  # 5
    (6, TType.LIST, 'log', (TType.STRUCT, [AlgorithmLog, None], False), None, ),  # 6
)
all_structs.append(AlgorithmDebug)
AlgorithmDebug.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'debugData', (TType.STRING, 'UTF8', TType.STRING, 'BINARY', False), None, ),  # 1
)
all_structs.append(AlgorithmUnion)
AlgorithmUnion.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'detectionResult', [Detection.ttypes.DetectionResult, None], None, ),  # 1
    (2, TType.STRUCT, 'identificationResult', [Identification.ttypes.IdentificationResult, None], None, ),  # 2
    (3, TType.STRUCT, 'localizationResult', [Localization.ttypes.LocalizationResult, None], None, ),  # 3
    (4, TType.STRUCT, 'directionalityResult', [Directionality.ttypes.DirectionalityResult, None], None, ),  # 4
    (5, TType.STRUCT, 'processedImageResult', [ProcessedImage.ttypes.ProcessedImageResult, None], None, ),  # 5
    (6, TType.STRUCT, 'ptuLocalizationResult', [NavigationSensor.ttypes.NavigationData, None], None, ),  # 6
)
all_structs.append(AlgorithmData)
AlgorithmData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'componentId', [UUID.ttypes.UUID, None], None, ),  # 1
    (2, TType.STRUCT, 'eventId', [UUID.ttypes.UUID, None], None, ),  # 2
    (3, TType.I64, 'startTimeStamp', None, None, ),  # 3
    (4, TType.I64, 'endTimeStamp', None, None, ),  # 4
    (5, TType.I32, 'health', None, None, ),  # 5
    (6, TType.STRUCT, 'contents', [AlgorithmUnion, None], None, ),  # 6
    (7, TType.STRUCT, 'debugResult', [AlgorithmDebug, None], None, ),  # 7
    (8, TType.I32, 'serverState', None, None, ),  # 8
    (9, TType.LIST, 'faults', (TType.STRUCT, [AlgorithmLog, None], False), None, ),  # 9
)
fix_spec(all_structs)
del all_structs
