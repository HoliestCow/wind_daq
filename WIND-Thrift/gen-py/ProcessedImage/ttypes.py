#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import Navigation.ttypes

from thrift.transport import TTransport
all_structs = []


class ImageResultType(object):
    ImageOverlay = 0
    MapOverlay = 1

    _VALUES_TO_NAMES = {
        0: "ImageOverlay",
        1: "MapOverlay",
    }

    _NAMES_TO_VALUES = {
        "ImageOverlay": 0,
        "MapOverlay": 1,
    }


class ProcessedImageConfiguration(object):
    """
    ProcessedImage allows any processed image generated by an algorithm to be
      to be transmitted. One algorithm may generate many different ProcessedImage data products and MUST
      provide a ProcessedImageDefinition for each one. The type of image is specified by the ImageResultType enum
      in the definition along with a text description. Current allowed types are an image with an overlay
      (e.g., a frame from a forward-facing camera with additional information overlaid on top of it) and a map overlay.

      The location at which the image was generated should be returned with each ProcessedImageResult.
    . In the case of ImageOverlay type, the location MUST be the location of the PTU when the image was captured.
      In the case of MapOverlay type, the location MUST be the top left corner of the overlay. The ImageOverlay type
      MUST additionally be returned with a horizontal and vertical FOV in degrees whereas the MapOverlay type MUST be
      returned with a width and height in meters.

    Attributes:
     - placeholder: Placeholder for actual configuration
    """


    def __init__(self, placeholder=None,):
        self.placeholder = placeholder

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.placeholder = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ProcessedImageConfiguration')
        if self.placeholder is not None:
            oprot.writeFieldBegin('placeholder', TType.BOOL, 1)
            oprot.writeBool(self.placeholder)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ProcessedImageDefinition(object):
    """
    Attributes:
     - description
     - imageResultType
    """


    def __init__(self, description=None, imageResultType=None,):
        self.description = description
        self.imageResultType = imageResultType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.imageResultType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ProcessedImageDefinition')
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 1)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        if self.imageResultType is not None:
            oprot.writeFieldBegin('imageResultType', TType.I32, 2)
            oprot.writeI32(self.imageResultType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ProcessedImageResult(object):
    """
    Attributes:
     - timeStamp
     - image
     - location
     - width
     - height
     - horizontalFOV
     - verticalFOV
    """


    def __init__(self, timeStamp=None, image=None, location=None, width=None, height=None, horizontalFOV=None, verticalFOV=None,):
        self.timeStamp = timeStamp
        self.image = image
        self.location = location
        self.width = width
        self.height = height
        self.horizontalFOV = horizontalFOV
        self.verticalFOV = verticalFOV

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.timeStamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.image = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.location = Navigation.ttypes.Location()
                    self.location.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.width = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.height = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.horizontalFOV = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.verticalFOV = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ProcessedImageResult')
        if self.timeStamp is not None:
            oprot.writeFieldBegin('timeStamp', TType.I64, 1)
            oprot.writeI64(self.timeStamp)
            oprot.writeFieldEnd()
        if self.image is not None:
            oprot.writeFieldBegin('image', TType.STRING, 4)
            oprot.writeBinary(self.image)
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRUCT, 5)
            self.location.write(oprot)
            oprot.writeFieldEnd()
        if self.width is not None:
            oprot.writeFieldBegin('width', TType.DOUBLE, 6)
            oprot.writeDouble(self.width)
            oprot.writeFieldEnd()
        if self.height is not None:
            oprot.writeFieldBegin('height', TType.DOUBLE, 7)
            oprot.writeDouble(self.height)
            oprot.writeFieldEnd()
        if self.horizontalFOV is not None:
            oprot.writeFieldBegin('horizontalFOV', TType.DOUBLE, 8)
            oprot.writeDouble(self.horizontalFOV)
            oprot.writeFieldEnd()
        if self.verticalFOV is not None:
            oprot.writeFieldBegin('verticalFOV', TType.DOUBLE, 9)
            oprot.writeDouble(self.verticalFOV)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ProcessedImageConfiguration)
ProcessedImageConfiguration.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'placeholder', None, None, ),  # 1
)
all_structs.append(ProcessedImageDefinition)
ProcessedImageDefinition.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'description', 'UTF8', None, ),  # 1
    (2, TType.I32, 'imageResultType', None, None, ),  # 2
)
all_structs.append(ProcessedImageResult)
ProcessedImageResult.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'timeStamp', None, None, ),  # 1
    None,  # 2
    None,  # 3
    (4, TType.STRING, 'image', 'BINARY', None, ),  # 4
    (5, TType.STRUCT, 'location', [Navigation.ttypes.Location, None], None, ),  # 5
    (6, TType.DOUBLE, 'width', None, None, ),  # 6
    (7, TType.DOUBLE, 'height', None, None, ),  # 7
    (8, TType.DOUBLE, 'horizontalFOV', None, None, ),  # 8
    (9, TType.DOUBLE, 'verticalFOV', None, None, ),  # 9
)
fix_spec(all_structs)
del all_structs
