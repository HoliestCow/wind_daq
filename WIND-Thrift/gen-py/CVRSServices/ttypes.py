#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import PTUPayload.ttypes
import UUID.ttypes
import Navigation.ttypes
import WINDMessage.ttypes
import Marker.ttypes
import Exceptions.ttypes

from thrift.transport import TTransport
all_structs = []


class StatusCode(object):
    OK = 0
    PROTOCOL_MISMATCH = 1

    _VALUES_TO_NAMES = {
        0: "OK",
        1: "PROTOCOL_MISMATCH",
    }

    _NAMES_TO_VALUES = {
        "OK": 0,
        "PROTOCOL_MISMATCH": 1,
    }


class ControlType(object):
    """
    Defines the types of commands that can be sent to the PTU. The payload that must accompany
    each type of control message is defined in the contract below.
    """
    START_RECORDING = 0
    END_RECORDING = 1
    UPDATE_WAYPOINT = 2
    DELETE_WAYPOINT = 3
    CLEAR_ALL_WAYPOINTS = 4
    UPDATE_BOUNDING_BOX = 5
    DELETE_BOUNDING_BOX = 6
    CLEAR_ALL_BOUNDING_BOXES = 7
    UPDATE_MESSAGE = 8
    DELETE_MESSAGE = 9
    CLEAR_ALL_MESSAGES = 10
    UPDATE_MARKER = 11
    DELETE_MARKER = 12
    CLEAR_ALL_MARKERS = 13
    UPDATE_MAP_OVERLAY = 14
    DELETE_MAP_OVERLAY = 15
    CLEAR_ALL_MAP_OVERLAYS = 16

    _VALUES_TO_NAMES = {
        0: "START_RECORDING",
        1: "END_RECORDING",
        2: "UPDATE_WAYPOINT",
        3: "DELETE_WAYPOINT",
        4: "CLEAR_ALL_WAYPOINTS",
        5: "UPDATE_BOUNDING_BOX",
        6: "DELETE_BOUNDING_BOX",
        7: "CLEAR_ALL_BOUNDING_BOXES",
        8: "UPDATE_MESSAGE",
        9: "DELETE_MESSAGE",
        10: "CLEAR_ALL_MESSAGES",
        11: "UPDATE_MARKER",
        12: "DELETE_MARKER",
        13: "CLEAR_ALL_MARKERS",
        14: "UPDATE_MAP_OVERLAY",
        15: "DELETE_MAP_OVERLAY",
        16: "CLEAR_ALL_MAP_OVERLAYS",
    }

    _NAMES_TO_VALUES = {
        "START_RECORDING": 0,
        "END_RECORDING": 1,
        "UPDATE_WAYPOINT": 2,
        "DELETE_WAYPOINT": 3,
        "CLEAR_ALL_WAYPOINTS": 4,
        "UPDATE_BOUNDING_BOX": 5,
        "DELETE_BOUNDING_BOX": 6,
        "CLEAR_ALL_BOUNDING_BOXES": 7,
        "UPDATE_MESSAGE": 8,
        "DELETE_MESSAGE": 9,
        "CLEAR_ALL_MESSAGES": 10,
        "UPDATE_MARKER": 11,
        "DELETE_MARKER": 12,
        "CLEAR_ALL_MARKERS": 13,
        "UPDATE_MAP_OVERLAY": 14,
        "DELETE_MAP_OVERLAY": 15,
        "CLEAR_ALL_MAP_OVERLAYS": 16,
    }


class Session(object):
    """
    Attributes:
     - status
     - sessionId
    """


    def __init__(self, status=None, sessionId=None,):
        self.status = status
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.sessionId = UUID.ttypes.UUID()
                    self.sessionId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Session')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 1)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRUCT, 2)
            self.sessionId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StartRecordingControlPayload(object):
    """
    Attributes:
     - campaign: The campaign name that the measurement is part of - can be blank
     - tag: A custom tag that can be applied to the measurement - can be blank
     - measurementNumber: A number that is used to keep track of the measurement - can be blank
     - description: A short description of what the measurement is - can be blank
     - location: A short description of where the meausurement was taken - can be blank
     - duration: Time in milliseconds for the PTU to run the measurement.  A zero is interpreted as infinite duration
     - recordingType: A type used to classify what the recording is
    """


    def __init__(self, campaign=None, tag=None, measurementNumber=None, description=None, location=None, duration=None, recordingType=None,):
        self.campaign = campaign
        self.tag = tag
        self.measurementNumber = measurementNumber
        self.description = description
        self.location = location
        self.duration = duration
        self.recordingType = recordingType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.campaign = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tag = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.measurementNumber = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.location = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.duration = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.recordingType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StartRecordingControlPayload')
        if self.campaign is not None:
            oprot.writeFieldBegin('campaign', TType.STRING, 1)
            oprot.writeString(self.campaign.encode('utf-8') if sys.version_info[0] == 2 else self.campaign)
            oprot.writeFieldEnd()
        if self.tag is not None:
            oprot.writeFieldBegin('tag', TType.STRING, 2)
            oprot.writeString(self.tag.encode('utf-8') if sys.version_info[0] == 2 else self.tag)
            oprot.writeFieldEnd()
        if self.measurementNumber is not None:
            oprot.writeFieldBegin('measurementNumber', TType.I32, 3)
            oprot.writeI32(self.measurementNumber)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 4)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 5)
            oprot.writeString(self.location.encode('utf-8') if sys.version_info[0] == 2 else self.location)
            oprot.writeFieldEnd()
        if self.duration is not None:
            oprot.writeFieldBegin('duration', TType.I64, 6)
            oprot.writeI64(self.duration)
            oprot.writeFieldEnd()
        if self.recordingType is not None:
            oprot.writeFieldBegin('recordingType', TType.I32, 7)
            oprot.writeI32(self.recordingType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ControlPayloadUnion(object):
    """
    Members of the ControlPayloadUnion. The contract describing which
    payload must accompany which ControlType is defined in the ControlType enum above.

    Attributes:
     - startRecordingPayload
     - waypoint
     - bBox
     - message
     - marker
     - id
     - overlay
    """


    def __init__(self, startRecordingPayload=None, waypoint=None, bBox=None, message=None, marker=None, id=None, overlay=None,):
        self.startRecordingPayload = startRecordingPayload
        self.waypoint = waypoint
        self.bBox = bBox
        self.message = message
        self.marker = marker
        self.id = id
        self.overlay = overlay

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.startRecordingPayload = StartRecordingControlPayload()
                    self.startRecordingPayload.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.waypoint = Navigation.ttypes.Waypoint()
                    self.waypoint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.bBox = Navigation.ttypes.BoundingBox()
                    self.bBox.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.message = WINDMessage.ttypes.Message()
                    self.message.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.marker = Marker.ttypes.Marker()
                    self.marker.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.id = UUID.ttypes.UUID()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.overlay = Navigation.ttypes.MapOverlay()
                    self.overlay.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ControlPayloadUnion')
        if self.startRecordingPayload is not None:
            oprot.writeFieldBegin('startRecordingPayload', TType.STRUCT, 1)
            self.startRecordingPayload.write(oprot)
            oprot.writeFieldEnd()
        if self.waypoint is not None:
            oprot.writeFieldBegin('waypoint', TType.STRUCT, 2)
            self.waypoint.write(oprot)
            oprot.writeFieldEnd()
        if self.bBox is not None:
            oprot.writeFieldBegin('bBox', TType.STRUCT, 3)
            self.bBox.write(oprot)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRUCT, 4)
            self.message.write(oprot)
            oprot.writeFieldEnd()
        if self.marker is not None:
            oprot.writeFieldBegin('marker', TType.STRUCT, 5)
            self.marker.write(oprot)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 6)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        if self.overlay is not None:
            oprot.writeFieldBegin('overlay', TType.STRUCT, 7)
            self.overlay.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ControlMessage(object):
    """
    Each ControlMessage is defined by a UUID, a required type and
    a payload that may be null.
    The type of payload that must accompany each ControlType is defined above.

    Attributes:
     - commandId
     - type
     - payload
    """


    def __init__(self, commandId=None, type=None, payload=None,):
        self.commandId = commandId
        self.type = type
        self.payload = payload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.commandId = UUID.ttypes.UUID()
                    self.commandId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.payload = ControlPayloadUnion()
                    self.payload.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ControlMessage')
        if self.commandId is not None:
            oprot.writeFieldBegin('commandId', TType.STRUCT, 1)
            self.commandId.write(oprot)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.STRUCT, 3)
            self.payload.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ControlMessageAck(object):
    """
    A list of ControlMessageAcks are sent to the CVRS by the PTU using the pushAcknowledgements method defined
    below. Each one is used to acknowledge whether or not a particular ControlMessage was carried out successfully. If the
    the ControlMessage could not be carried out, an exception MUST be included.

    Attributes:
     - commandId: This UUID of the corresponding ControlMessage
     - success: Whether or not the command was executed successfully
     - specificException: If it was not carried out successfully, the exception that occurred
    """


    def __init__(self, commandId=None, success=None, specificException=None,):
        self.commandId = commandId
        self.success = success
        self.specificException = specificException

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.commandId = UUID.ttypes.UUID()
                    self.commandId.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.specificException = Exceptions.ttypes.ExceptionUnion()
                    self.specificException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ControlMessageAck')
        if self.commandId is not None:
            oprot.writeFieldBegin('commandId', TType.STRUCT, 1)
            self.commandId.write(oprot)
            oprot.writeFieldEnd()
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 2)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.specificException is not None:
            oprot.writeFieldBegin('specificException', TType.STRUCT, 3)
            self.specificException.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RecordingUpdate(object):
    """
    Used to optionally send a RecordingConfiguration as one of the parameters of the define method
    described below.

    Attributes:
     - recordingConfig
    """


    def __init__(self, recordingConfig=None,):
        self.recordingConfig = recordingConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.recordingConfig = PTUPayload.ttypes.RecordingConfiguration()
                    self.recordingConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RecordingUpdate')
        if self.recordingConfig is not None:
            oprot.writeFieldBegin('recordingConfig', TType.STRUCT, 1)
            self.recordingConfig.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DefinitionAndConfigurationUpdate(object):
    """
    Used to optionally send a SystemDefinition and a SystemConfiguration as parameters of the reportStatus
    and pushData methods described below. The definition and configuration should be included only if they
    have changed in their respective contexts (i.e., the current PTU status being reported via reportStatus or
    the stream of data, which may be historical, being pushed)

    Attributes:
     - systemDefinition
     - systemConfiguration
    """


    def __init__(self, systemDefinition=None, systemConfiguration=None,):
        self.systemDefinition = systemDefinition
        self.systemConfiguration = systemConfiguration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.systemDefinition = PTUPayload.ttypes.SystemDefinition()
                    self.systemDefinition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.systemConfiguration = PTUPayload.ttypes.SystemConfiguration()
                    self.systemConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DefinitionAndConfigurationUpdate')
        if self.systemDefinition is not None:
            oprot.writeFieldBegin('systemDefinition', TType.STRUCT, 1)
            self.systemDefinition.write(oprot)
            oprot.writeFieldEnd()
        if self.systemConfiguration is not None:
            oprot.writeFieldBegin('systemConfiguration', TType.STRUCT, 2)
            self.systemConfiguration.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Session)
Session.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'status', None, None, ),  # 1
    (2, TType.STRUCT, 'sessionId', [UUID.ttypes.UUID, None], None, ),  # 2
)
all_structs.append(StartRecordingControlPayload)
StartRecordingControlPayload.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'campaign', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tag', 'UTF8', None, ),  # 2
    (3, TType.I32, 'measurementNumber', None, None, ),  # 3
    (4, TType.STRING, 'description', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'location', 'UTF8', None, ),  # 5
    (6, TType.I64, 'duration', None, None, ),  # 6
    (7, TType.I32, 'recordingType', None, None, ),  # 7
)
all_structs.append(ControlPayloadUnion)
ControlPayloadUnion.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'startRecordingPayload', [StartRecordingControlPayload, None], None, ),  # 1
    (2, TType.STRUCT, 'waypoint', [Navigation.ttypes.Waypoint, None], None, ),  # 2
    (3, TType.STRUCT, 'bBox', [Navigation.ttypes.BoundingBox, None], None, ),  # 3
    (4, TType.STRUCT, 'message', [WINDMessage.ttypes.Message, None], None, ),  # 4
    (5, TType.STRUCT, 'marker', [Marker.ttypes.Marker, None], None, ),  # 5
    (6, TType.STRUCT, 'id', [UUID.ttypes.UUID, None], None, ),  # 6
    (7, TType.STRUCT, 'overlay', [Navigation.ttypes.MapOverlay, None], None, ),  # 7
)
all_structs.append(ControlMessage)
ControlMessage.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'commandId', [UUID.ttypes.UUID, None], None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
    (3, TType.STRUCT, 'payload', [ControlPayloadUnion, None], None, ),  # 3
)
all_structs.append(ControlMessageAck)
ControlMessageAck.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'commandId', [UUID.ttypes.UUID, None], None, ),  # 1
    (2, TType.BOOL, 'success', None, None, ),  # 2
    (3, TType.STRUCT, 'specificException', [Exceptions.ttypes.ExceptionUnion, None], None, ),  # 3
)
all_structs.append(RecordingUpdate)
RecordingUpdate.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'recordingConfig', [PTUPayload.ttypes.RecordingConfiguration, None], None, ),  # 1
)
all_structs.append(DefinitionAndConfigurationUpdate)
DefinitionAndConfigurationUpdate.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'systemDefinition', [PTUPayload.ttypes.SystemDefinition, None], None, ),  # 1
    (2, TType.STRUCT, 'systemConfiguration', [PTUPayload.ttypes.SystemConfiguration, None], None, ),  # 2
)
fix_spec(all_structs)
del all_structs
