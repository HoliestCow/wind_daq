#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import Spectrum.ttypes
import Navigation.ttypes
import Common.ttypes

from thrift.transport import TTransport
all_structs = []


class LocalizationConfiguration(object):
    """
    Localizations are produced by the Algorithm and returned to the
    DAQ for the UI and archiving.

    Attributes:
     - placeholder: Placeholder for actual configuration
    """


    def __init__(self, placeholder=None,):
        self.placeholder = placeholder

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.placeholder = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LocalizationConfiguration')
        if self.placeholder is not None:
            oprot.writeFieldBegin('placeholder', TType.BOOL, 1)
            oprot.writeBool(self.placeholder)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LocalizationDefinition(object):
    """
    Attributes:
     - initialConfiguration
     - type: Type of directionality result being reported.
    """


    def __init__(self, initialConfiguration=None, type=None,):
        self.initialConfiguration = initialConfiguration
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.initialConfiguration = LocalizationConfiguration()
                    self.initialConfiguration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LocalizationDefinition')
        if self.initialConfiguration is not None:
            oprot.writeFieldBegin('initialConfiguration', TType.STRUCT, 1)
            self.initialConfiguration.write(oprot)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LocalizationResult(object):
    """
    Localization results indicate the position of a source over
    a period of time. This is to support placing the estimated
    source position on a map display.

    Localization results are reported as available whenever the
    algorithm has sufficient information to update the position.

    Localization results are assumed to be cummulative over the
    period of time that the source was in view.  The time period
    reported for the localization results shall be the period of
    time that source has been present at that location.  For a
    stationary source this would be the entire encounter duration and
    thus the startTimestamp would be fixed.  For a moving source,
    the starting time would advance to reflect the earliest data
    which reflects this new position.  As the estimate of the
    location may used data which was previously used for a
    previous estimate, the timesamples between a previous report
    and the revised report may have overlapping timestamps.

    Localization results must be associated with an event id.
    At most one localization result may be produced for each
    event id per localization algorithm.

    If algorithms report gamma and neutron localization as
    independent results, they will define a separate localization
    algorithm for each sensor type.

    Localization results may report an uncertainty in the source
    position.  Each dimension is assumed to have an independent
    uncertainty.

    FIXME do we need to define the type of localization result
    if the algorithm is of type Gamma/Neutron?  This could be
    implied from the detection result, but it is not clear in
    detection whether it is a gamma or neutron source.

    FIXME we need a new type to define uncertainties about a
    position.  Our current system defines uncertainty along the
    axis and thus does not adequately describe an elipsode
    with an axis whose major axis is not along the coordinate axis.


    Attributes:
     - location: The estimated location of the source for the starting to
    ending timestamp reported.  The source is assumed to be
    at that position until a revised localization result is
    produced.
     - uncertainty: Uncertainty of location of the source in terms of a one standard
    deviation in each direction as an ellipsoid.
    """


    def __init__(self, location=None, uncertainty=None,):
        self.location = location
        self.uncertainty = uncertainty

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.location = Navigation.ttypes.Location()
                    self.location.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.uncertainty = Navigation.ttypes.LocationUncertainty()
                    self.uncertainty.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LocalizationResult')
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRUCT, 1)
            self.location.write(oprot)
            oprot.writeFieldEnd()
        if self.uncertainty is not None:
            oprot.writeFieldBegin('uncertainty', TType.STRUCT, 2)
            self.uncertainty.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(LocalizationConfiguration)
LocalizationConfiguration.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'placeholder', None, None, ),  # 1
)
all_structs.append(LocalizationDefinition)
LocalizationDefinition.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'initialConfiguration', [LocalizationConfiguration, None], None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
)
all_structs.append(LocalizationResult)
LocalizationResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'location', [Navigation.ttypes.Location, None], None, ),  # 1
    (2, TType.STRUCT, 'uncertainty', [Navigation.ttypes.LocationUncertainty, None], None, ),  # 2
)
fix_spec(all_structs)
del all_structs
