/******************************************************************************
*
* CAEN SpA - Front End Division
* Via Vetraia, 11 - 55049 - Viareggio ITALY
* +390594388398 - www.caen.it
*
***************************************************************************//**
* \note TERMS OF USE:
* This program is free software; you can redistribute it and/or modify it under
* the terms of the GNU General Public License as published by the Free Software
* Foundation. This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. The user relies on the
* software, documentation and results solely at his own risk.
******************************************************************************/

#include "digiTES.h"
#include "PreProcess.h"
#include "ZCcal.h"
#include "Console.h"

// --------------------------------------------------------------------------------------------------------- 
// Global Variables
// --------------------------------------------------------------------------------------------------------- 

uint64_t PrevTime[MAX_NBRD][MAX_NCH];		// previous timestamps (used to check rollover and extend to 64 bit)
uint64_t ExtendedTime[MAX_NBRD][MAX_NCH];   // Extended timestamps (higher bits of the 64bit word)
void *DPPdecode_WaveBuff;					// memory buffer for the waveform decoded by the CAENdigitizer lib
uint16_t *WPsmooth;							// smoothed waveform generated by the WaveformProcessor
int16_t  *WPdiscr;							// discriminator waveform generated by the WaveformProcessor
uint16_t WPmaxNs;							// Max num of samples in the WaveformProcessor

// --------------------------------------------------------------------------------------------------------- 
// Description: Off-line implementation of the discriminator (LED or CFD), time interpolation and PSD
//				The results are written into the Event (including discriminator waveform)
// Inputs:		b = Board Number
//				c = channel number
// InOuts:		Event = Event data
// Outputs		Waveout = waveform generated by the processor (e.g. CFD)
// Return:		0=OK, -1=error
// --------------------------------------------------------------------------------------------------------- 
// TODO: remove trigger jitter with STD FW (shift waveforms and fill initial/final gaps by copying first/last sample)
static int SW_WaveformProcessor(int b, int ch, int ns, uint16_t *Wavein, GenericDPPEvent_t *Event, uint16_t *Waveout, uint8_t *Dprobes)
{
	int i, nsbl=0, ncross=0, armed=0, bslstop, sign, wpns;
	int LGwidth, SGwidth, PreGate, CFDdelay;
	uint32_t Qs=0, Ql=0;
	uint16_t Baseline;
	int16_t ZCneg=0, ZCpos=0;
	uint32_t bslacc, smean, smn;
	float atten;

	wpns = (ns <= WPmaxNs) ? ns : WPmaxNs;

	LGwidth = WDcfg.GateWidth[b][ch]/WDcfg.Tsampl;
	SGwidth = WDcfg.ShortGateWidth[b][ch]/WDcfg.Tsampl;
	PreGate = WDcfg.PreGate[b][ch]/WDcfg.Tsampl;
	CFDdelay = WDcfg.CFDdelay[b][ch]/WDcfg.Tsampl;

	if      (WDcfg.CFDfraction[b][ch] == 0) atten = 0.25;
	else if (WDcfg.CFDfraction[b][ch] == 1) atten = 0.50;
	else if (WDcfg.CFDfraction[b][ch] == 2) atten = 0.75;
	else if (WDcfg.CFDfraction[b][ch] == 3) atten = 1.00;

	// discriminator is intended for negative pulses; if positive, invert it (NOTE: in PHA, negaive signals are already inverted by the FPGA, so they are always positive)
	if ((WDcfg.PulsePolarity[b][ch] == 0) || (WDcfg.DppType == DPP_PHA_724))
		sign = -1;
	else
		sign = 1;

	if ((WPdiscr == NULL) || (WPsmooth == NULL))
		return -1;

	// Calculate baseline and apply smoothing
	smean = 0;
	smn = 0;
	bslacc = 0;
	bslstop = 0;
	for(i=0; i<wpns ; i++) {
		Dprobes[i] = (bslstop << 3);
		if (!bslstop) {
			if (nsbl < (1 << (2*WDcfg.NsBaseline[b][ch]))) {
				bslacc += Wavein[i];
				nsbl++;
			} else {
				bslacc += Wavein[i] - Wavein[i-nsbl];
			}
		}
		Baseline = bslacc/nsbl;
		if ((abs(Wavein[i+5] - Baseline) > (WDcfg.TrgThreshold[b][ch])))
			bslstop = 1;

		if (smn < (uint32_t)(1 << WDcfg.TTFsmoothing[b][ch])) {
			smean += Wavein[i];
			smn++;
		} else {
			smean += Wavein[i] - Wavein[i-smn];
		}
		WPsmooth[i] = smean/smn;  // smoothed input signal

	}

	// calculate discriminator waveform (either LED or CFD)
	for(i=0; i<wpns ; i++) {
		if (WDcfg.DiscrMode[b][ch] == 1) {  // CFD
			if (i >= WDcfg.CFDdelay[b][ch])
				WPdiscr[i] = (int16_t)(sign * (atten * (WPsmooth[i] - Baseline) - (WPsmooth[i - CFDdelay] - Baseline)));
			else
				WPdiscr[i] = sign * (WPsmooth[i] - Baseline);
			if (!armed && (WPdiscr[i] < -WDcfg.TrgThreshold[b][ch]))
				armed = 1;
			if (armed && (ncross==0) && (WPdiscr[i] >= 0)) {
				ncross = i;
				Dprobes[i] |= 1; // trigger
				if (WDcfg.CFDinterp[b][ch] == 0) {
					ZCneg = WPdiscr[i-1];
					ZCpos = WPdiscr[i];
				} else {
					ZCneg = WPdiscr[i-2];
					ZCpos = WPdiscr[i+1];
				}
			}
		} else {  // LED
			WPdiscr[i] = sign * (WPsmooth[i] - Baseline); 
			if ((ncross==0) && (WPdiscr[i] < -WDcfg.TrgThreshold[b][ch])) {
				ncross = i;
				Dprobes[i] |= 1; // trigger
				ZCneg = WDcfg.TrgThreshold[b][ch] - WPdiscr[i-1];
				ZCpos = WDcfg.TrgThreshold[b][ch] - WPdiscr[i];
			}
		}
		if (Waveout != NULL)
			Waveout[i] = (uint16_t)WPdiscr[i] + (1<<WDcfg.Nbit)/2;

		if ((ncross>0) && (i <= (ncross + LGwidth - PreGate))) {
			Ql += (Baseline - Wavein[i-PreGate]);
			Dprobes[i-PreGate] |= 0x2; // long gate
		}
		if ((ncross>0) && (i <= (ncross + SGwidth - PreGate))) {
			Qs += (Baseline- Wavein[i-PreGate]);
			Dprobes[i-PreGate] |= 0x4; // short gate
		}
	}

	// timing interpolation
	if (WDcfg.WaveformProcessor & 0x01) {
		if (ncross > 0) {
			Event->TimeStamp += WDcfg.Tsampl * ncross;
			if ((ZCneg < 0) && (ZCpos >= 0)) {
				if (WDcfg.CFDinterp[b][ch] == 0)
					Event->FineTimeStamp = (uint16_t)(1000 * WDcfg.Tsampl * (-ZCneg) / (ZCpos - ZCneg));  // fine tstamp is expressed in ps
				else
					Event->FineTimeStamp = (uint16_t)(1000 * 2*WDcfg.Tsampl * ((-ZCneg) / (ZCneg - ZCpos) - 0.5));
			} else {
				Event->FineTimeStamp = 0;
			}
		} else {
			Event->FineTimeStamp = 0;
		}
	} 

	// energy and psd
	if (WDcfg.WaveformProcessor & 0x02) {
		Event->Energy = Ql;
		Event->psd = (float)(Ql-Qs)/Ql;
	}

	return 0;
}



// --------------------------------------------------------------------------------------------------------- 
// Description: Init Global Variables and allocate memory for the waveforms
// Inputs:		-
// Outputs:		AllocatedSize: total number of bytes allocated by the function
// Return:		0=OK, -1=error
// --------------------------------------------------------------------------------------------------------- 
int InitPreProcess(uint32_t *AllocatedSize)
{
	int b, ch, ret=0, alloc, loadzcc=0, zcfailed=0;

	for(b=0; b<MAX_NBRD; b++) {
		for (ch=0; ch<MAX_NCH; ch++) {
			PrevTime[b][ch] = 0;
			ExtendedTime[b][ch] = 0;
		}
	}
	if (ACQ_MODE_PLUGGED(WDcfg.AcquisitionMode) && IS_DPP_FW(WDcfg.DppType) && (DPPdecode_WaveBuff == NULL)) {
		ret = CAEN_DGTZ_MallocDPPWaveforms(handle[0], &DPPdecode_WaveBuff, AllocatedSize); 
	}
	if (WDcfg.WaveformProcessor) {
		// allocate processed waveforms
		if (WPdiscr == NULL) 	
			WPdiscr = (int16_t *)malloc(WDcfg.RecordLength * sizeof(uint16_t));
		if (WPsmooth == NULL)	
			WPsmooth = (uint16_t *)malloc(WDcfg.RecordLength * sizeof(uint16_t));
		WPmaxNs = WDcfg.RecordLength; // to prevent longer waveform to make a memory overflow
	}


	// create ZCcalibration tables
	for(b=0; b<MAX_NBRD; b++) {
		for (ch=0; ch<MAX_NCH; ch++) {
			if ((WDcfg.EnableZCcalibr[b][ch] || WDcfg.CalibrationRun) && WDcfg.EnableInput[b][ch]) {
				if (ZCcal_CreateZCTable(b, ch, &alloc) < 0) {
					loadzcc = 0;
					zcfailed = 1;
					b = MAX_NBRD;
					break;
				} else {
					AllocatedSize += alloc;
					if (WDcfg.CalibrationRun) {
						ZCcal_ResetZCTables(SysVars.ZCcorr_Ncnt);
					} else {
						loadzcc = 1;
					}
				}
			}
		}
	}

	if (loadzcc) {
		ZCcal_LoadCorrectionTables(SysVars.ZCcalibrFileName);
		msg_printf(MsgLog, "INFO: ZC calibration table loaded from %s\n", SysVars.ZCcalibrFileName);
	} else if (zcfailed) {
		msg_printf(MsgLog, "WARNING: can't load ZC calibration table\n");
	}

	return ret;
}


// --------------------------------------------------------------------------------------------------------- 
// Description:	Free memory buffer
// Return:		0=OK, -1=error
// --------------------------------------------------------------------------------------------------------- 
int ClosePreProcess()
{
	CAEN_DGTZ_FreeDPPWaveforms(handle[0], DPPdecode_WaveBuff);
	DPPdecode_WaveBuff = NULL;
	if (WPdiscr != NULL)	free(WPdiscr);
	if (WPsmooth != NULL)	free(WPsmooth);
	ZCcal_DestroyZCTables();
	return 0;
}


// --------------------------------------------------------------------------------------------------------- 
// Description: Convert data from the struct of the CAEN_DGTZ library to a generic struct valid for any DPP
// Inputs:		int b = Board Number
//				int ch = Channel Number
//				ev = Event number
//				Event = data source (event list given by the CAEN DGTZ library)
// Outputs:		EventData = data destination (generic event)
//				Wfm = waveform data
// Return: 0=OK, -1=error
// --------------------------------------------------------------------------------------------------------- 
int PreProcessEvent(int b, int ch, int ev, void *Event, GenericDPPEvent_t *EventData, Waveform_t *Wfm)
{
	uint64_t ts, TSmask;
	uint32_t extra_sel = -1;
	int i, ovf=0;

	EventData->FineTimeStamp = 0;
	EventData->Flags = 0;
	EventData->Waveforms = NULL;

	// Take trace settings from the global variable in the software and not from data reaad from the board (trace settings are present in the "format").
	// Trace settings are assigned here only in case of data from file.
	if (Wfm != NULL)
		for(i=0; i<MAX_NTRACES; i++)
			Wfm->TraceSet[i] = TraceSet[i];

	// ##########################################################################################
	// DPP_CI (720)
	// ##########################################################################################
	if (WDcfg.DppType == DPP_CI) {
		CAEN_DGTZ_DPP_CI_Event_t *EventCI = &((CAEN_DGTZ_DPP_CI_Event_t *)Event)[ev];
		CAEN_DGTZ_DPP_CI_Waveforms_t *WaveformCI = (CAEN_DGTZ_DPP_CI_Waveforms_t *)DPPdecode_WaveBuff;

		// --------------------------------------
		// Time Stamp
		// --------------------------------------
		TSmask = 0x7FFFFFFF;
		if (EventCI->TimeTag < PrevTime[b][ch])
			ExtendedTime[b][ch] += (TSmask+1);
		EventData->TimeStamp = (ExtendedTime[b][ch] + (uint64_t)EventCI->TimeTag) * WDcfg.Tsampl + (uint64_t)WDcfg.TstampOffset[b][ch];
		PrevTime[b][ch] = EventCI->TimeTag;

		Stats.EvInput_cnt[b][ch] = -1; // not available

		// --------------------------------------
		// Energy (original energy is 16 bit; the parameter EnergyMult applies the energy gain and the rebinning to EHnbin)
		// --------------------------------------
		if (EventCI->Charge == 0xFFFF) {
			EventData->Energy = 0xFFFF;
			ovf = 1;
			EventData->Flags |= EVFLAGS_E_OVR;
		} else if (EventCI->Charge == 0) {
			EventData->Energy = 0;
			ovf = 1;
			EventData->Flags |= EVFLAGS_E_UNR;
		} else if (WDcfg.EnergyFineGain[b][ch] != 1.0) {
			double ef = (uint16_t)EventCI->Charge / WDcfg.EnergyDiv[b][ch] * WDcfg.EnergyFineGain[b][ch] + ((float)rand() / (float)(RAND_MAX)) - 0.5;
			if (ef < 0x7FFF) {
				EventData->Energy = (uint16_t)(ef);
			} else {
				EventData->Energy = 0xFFFF;
				Stats.EvOvf_cnt[b][ch]++;
				EventData->Flags |= EVFLAGS_E_OVR;
			}
		} else {
			EventData->Energy = (uint16_t)((uint16_t)EventCI->Charge / WDcfg.EnergyDiv[b][ch]);
		}
		if (ovf || (EventData->Energy >= WDcfg.EHnbin))
			Stats.EvOvf_cnt[b][ch]++;



		// --------------------------------------
		// Waveforms
		// --------------------------------------
		if ((EventCI->Waveforms != NULL) && (Wfm != NULL)) {
			CAEN_DGTZ_DecodeDPPWaveforms(handle[b], EventCI, WaveformCI);
			Wfm->Ns = WaveformCI->Ns;
			Wfm->DualTrace = WaveformCI->dualTrace;
			memcpy(Wfm->AnalogTrace[0], WaveformCI->Trace1, Wfm->Ns * sizeof(uint16_t));
			if (WDcfg.WaveformProcessor)
				SW_WaveformProcessor(b, ch, Wfm->Ns, WaveformCI->Trace1, EventData, Wfm->AnalogTrace[1], Wfm->DigitalTraces);
			else if (Wfm->DualTrace)
				memcpy(Wfm->AnalogTrace[1], WaveformCI->Trace2, Wfm->Ns * sizeof(uint16_t));
			for(i=0; i<Wfm->Ns; i++) 
				Wfm->DigitalTraces[i] = WaveformCI->DTrace1[i] | (WaveformCI->DTrace2[i] << 1) | (WaveformCI->DTrace3[i] << 2) | (WaveformCI->DTrace4[i] << 3);
			EventData->Waveforms = Wfm;
		}


	// ##########################################################################################
	// DPP_PSD (720, 751, 730, 725)
	// ##########################################################################################
	} else if ((WDcfg.DppType == DPP_PSD_720) || (WDcfg.DppType == DPP_PSD_751) || (WDcfg.DppType == DPP_PSD_730)) {
		CAEN_DGTZ_DPP_PSD_Event_t *EventPSD = &((CAEN_DGTZ_DPP_PSD_Event_t *)Event)[ev];
		CAEN_DGTZ_DPP_PSD_Waveforms_t *WaveformPSD = (CAEN_DGTZ_DPP_PSD_Waveforms_t *)DPPdecode_WaveBuff;

		// extra option
		if (WDcfg.DigitizerModel == 751)
			extra_sel = EventPSD->Format2 & 0x7;
		else if ((EventPSD->Format >> 28) & 0x1)
			extra_sel = (EventPSD->Format >> 24) & 0x7;

		// --------------------------------------
		// Time Stamp
		// --------------------------------------
		TSmask = (WDcfg.DppType == DPP_PSD_751) ? 0xFFFFFFFF : 0x7FFFFFFF;
		ts = (uint64_t)EventPSD->TimeTag;
		if ((extra_sel <= 3) && (extra_sel > 0) && (WDcfg.DppType == DPP_PSD_730)) {  // tstamp from the board is 47 bit (16 bits in the extras)  
			ExtendedTime[b][ch] = ((uint64_t)((EventPSD->Extras>>16) & 0xFFFF) << 31);
			EventData->TimeStamp = (ExtendedTime[b][ch] + ts) * WDcfg.Tsampl + (uint64_t)WDcfg.TstampOffset[b][ch];
			/*if (EventData->TimeStamp < PrevTime[b][ch]) 
				printf("ERROR: Time stamp rollback on brd %d, ch %d\n", b, ch);*/
			PrevTime[b][ch] = EventData->TimeStamp;
		} else {  // tstamp from the board is 31 bit
			if (ts < PrevTime[b][ch])
				ExtendedTime[b][ch] += (TSmask+1);
			EventData->TimeStamp = (ExtendedTime[b][ch] + ts) * WDcfg.Tsampl + (uint64_t)WDcfg.TstampOffset[b][ch];
			PrevTime[b][ch] = ts;
		}

		// --------------------------------------
		// flags and trigger counters
		// --------------------------------------
		if ((WDcfg.DppType == DPP_PSD_730) && ((extra_sel==1) || (extra_sel==2))) {
			if (EventPSD->Extras & (1<<13))	{  // flag counting 1024 triggers seen at the input
				Stats.EvInput_cnt[b][ch] += 1024;
				Stats.ICRUpdateTime[b][ch] = EventData->TimeStamp;
			}
			if ((WDcfg.FWrev >= 9) && (EventPSD->Extras & (1<<12)))	{  // flag counting 1024 lost triggers
				Stats.EvLost_cnt[b][ch] += 1024;
				Stats.LostTrgUpdateTime[b][ch] = EventData->TimeStamp;
			}

			if (EventPSD->Extras & (1<<14)) {
				EventData->Flags |= EVFLAGS_SATUR;
				Stats.Satur_cnt[b][ch]++;
			}
			if (EventPSD->Extras & (1<<15)) 
				EventData->Flags |= EVFLAGS_DEADTIME;
		} else {
			Stats.EvInput_cnt[b][ch] = -1; // not available
		}

		if ((EventPSD->Pur) && (WDcfg.DppType != DPP_PSD_720))  // HACK: check why PUR flag is not working with x720!
			EventData->Flags |= EVFLAGS_PILEUP;

		// in case of memory full, calculate the busy time
		if (EventData->Flags & EVFLAGS_DEADTIME)
			Stats.BusyTimeGap[b][ch] += (EventData->TimeStamp - Stats.LatestReadTstamp[b][ch]);

		// --------------------------------------
		// Energy (original energy is 16 bit; the parameter EnergyMult applies the energy gain and the rebinning to EHnbin)
		// --------------------------------------
		if ((uint16_t)EventPSD->ChargeLong == 0xFFFF) {
			EventData->Energy = 0xFFFF;
			ovf = 1;
			EventData->Flags |= EVFLAGS_E_OVR;
		} else if (EventPSD->ChargeLong == 0) {
			EventData->Energy = 0;
			ovf = 1;
			EventData->Flags |= EVFLAGS_E_UNR;
		} else if (WDcfg.EnergyFineGain[b][ch] != 1.0) {
			double ef = (uint16_t)EventPSD->ChargeLong / WDcfg.EnergyDiv[b][ch] * WDcfg.EnergyFineGain[b][ch] + ((float)rand() / (float)(RAND_MAX)) - 0.5;
			if (ef < 0x7FFF) {
				EventData->Energy = (uint16_t)(ef);
			} else {
				EventData->Energy = 0xFFFF;
				Stats.EvOvf_cnt[b][ch]++;
				EventData->Flags |= EVFLAGS_E_OVR;
			}
		} else {
			EventData->Energy = (uint16_t)EventPSD->ChargeLong / 4;
		}
		if (ovf || (EventData->Energy >= WDcfg.EHnbin))
			Stats.EvOvf_cnt[b][ch]++;


		// --------------------------------------
		// PSD
		// --------------------------------------
		if ((EventPSD->ChargeLong > 0) && (EventPSD->ChargeLong != 0xFFFF) && (EventPSD->ChargeShort != 0x7FFF) && (EventPSD->ChargeLong > EventPSD->ChargeShort))
			EventData->psd = (float)(EventPSD->ChargeLong - EventPSD->ChargeShort)/(EventPSD->ChargeLong);
		else
			EventData->psd = 0;

		// --------------------------------------
		// Fine Time stamp
		// --------------------------------------
		if ((SysVars.FineTstampMode > 0) && ((WDcfg.DppType == DPP_PSD_730) || ((WDcfg.DppType == DPP_PSD_751) && (WDcfg.FWrev >= 8)))) {
			uint16_t ZCneg, ZCpos, ZCthr;
			uint16_t dt = (1  +  WDcfg.CFDinterp[b][ch]*2) * 1000 * WDcfg.Tsampl;  // time interval between the interpolated points (in ps)
			uint16_t zc_interp = 0;

			if (extra_sel == 2) {  
				zc_interp = EventPSD->Extras & 0x3FF;
			} else {
				ZCneg = EventPSD->Extras & 0xFFFF;
				ZCpos = (EventPSD->Extras>>16) & 0xFFFF;
				if (WDcfg.DiscrMode[b][ch] == 0)  // LED
					ZCthr = (uint16_t)WDcfg.TrgThreshold[b][ch];
				else  // CFD
					ZCthr = 8192;
				if ((ZCneg < ZCthr) && (ZCpos >= ZCthr))
					zc_interp = 1024 * (ZCthr - ZCneg) / (ZCpos - ZCneg);  // fine tstamp is expressed in ps 
			}

			if (WDcfg.EnableZCcalibr[b][ch])
				zc_interp = ZCcal_ApplyCorrection(b, ch, zc_interp, EventPSD->ChargeLong);
			EventData->FineTimeStamp = dt * zc_interp / 1024;
			if (WDcfg.CalibrationRun) 
				if (!WDcfg.EnableEnergyFilter || (((float)EventData->Energy >= WDcfg.EnergyLCut[b][ch]) && (((float)EventData->Energy <= WDcfg.EnergyUCut[b][ch]))))
					ZCcal_AddSample(b, ch, zc_interp, EventPSD->ChargeLong);
		} else {
			EventData->FineTimeStamp = 0;
		}

		// --------------------------------------
		// Waveforms
		// --------------------------------------
		if ((EventPSD->Waveforms != NULL) && (Wfm != NULL)) {
			CAEN_DGTZ_DecodeDPPWaveforms(handle[b], EventPSD, WaveformPSD);
			Wfm->Ns = WaveformPSD->Ns;
			if (Wfm->Ns > WDcfg.RecordLength)
				Wfm->Ns = WDcfg.RecordLength;  // in the 751 the number of samples can be higher than RecordLength
			Wfm->DualTrace = WaveformPSD->dualTrace;

			memcpy(Wfm->AnalogTrace[0], WaveformPSD->Trace1, Wfm->Ns * sizeof(uint16_t));

			if (WDcfg.WaveformProcessor)
				SW_WaveformProcessor(b, ch, Wfm->Ns, WaveformPSD->Trace1, EventData, Wfm->AnalogTrace[1], Wfm->DigitalTraces);
			else if (Wfm->DualTrace)
				memcpy(Wfm->AnalogTrace[1], WaveformPSD->Trace2, Wfm->Ns * sizeof(uint16_t));

			if (WDcfg.DppType == DPP_PSD_720) {
				for(i=0; i<Wfm->Ns; i++) 
					Wfm->DigitalTraces[i] = WaveformPSD->DTrace1[i] | (WaveformPSD->DTrace2[i] << 1) | (WaveformPSD->DTrace3[i] << 2) | (WaveformPSD->DTrace4[i] << 3);
			} else if (WDcfg.DppType == DPP_PSD_730) {
				for(i=0; i<Wfm->Ns; i++) 
					Wfm->DigitalTraces[i] = WaveformPSD->DTrace1[i] | (WaveformPSD->DTrace2[i] << 1);
			} else if (WDcfg.DppType == DPP_PSD_751) {
				for(i=0; i<Wfm->Ns; i++) 
					Wfm->DigitalTraces[i] = WaveformPSD->DTrace1[i] | (WaveformPSD->DTrace2[i] << 1) | (WaveformPSD->DTrace3[i] << 2);
			}
			EventData->Waveforms = Wfm;
		}


	// ##########################################################################################
	// DPP_PHA (724, 730, 725)
	// ##########################################################################################
	} else if ((WDcfg.DppType == DPP_PHA_724) || (WDcfg.DppType == DPP_nPHA_724) ||  (WDcfg.DppType == DPP_PHA_730)) {
		CAEN_DGTZ_DPP_PHA_Event_t *EventPHA = &((CAEN_DGTZ_DPP_PHA_Event_t *)Event)[ev];
		CAEN_DGTZ_DPP_PHA_Waveforms_t *WaveformPHA = (CAEN_DGTZ_DPP_PHA_Waveforms_t *)DPPdecode_WaveBuff;

		if ((WDcfg.DppType == DPP_PHA_730) && ((EventPHA->Format >> 28) & 0x1)) 
			extra_sel = (EventPHA->Format >> 24) & 0x7;

		// --------------------------------------
		// Time Stamp
		// --------------------------------------
		if ((WDcfg.DppType == DPP_PHA_724) || (WDcfg.DppType == DPP_nPHA_724))	TSmask = 0x3FFFFFFF;
		else TSmask = 0x7FFFFFFF;

		ts = (uint64_t)EventPHA->TimeTag & TSmask;
		if ((WDcfg.DppType == DPP_PHA_730) && (extra_sel <= 3) && (extra_sel > 0)) {  // tstamp from the board is 47 bit (16 bits in the extras)  
			ExtendedTime[b][ch] = ((uint64_t)((EventPHA->Extras2>>16) & 0xFFFF) << 31);
		} else {  // tstamp from the board is 31 bit
			if (SysVars.UseRollOverFakeEvents) {
				if ((EventPHA->Extras & 0x2) == 0x2)
					ExtendedTime[b][ch] += (TSmask+1);
			} else {
				if (EventPHA->TimeTag < PrevTime[b][ch])
					ExtendedTime[b][ch] += (TSmask+1);
			}
		}
		EventData->TimeStamp = (ExtendedTime[b][ch] + ts) * WDcfg.Tsampl + (uint64_t)WDcfg.TstampOffset[b][ch];
		PrevTime[b][ch] = ts;

		// --------------------------------------
		// flags and trigger counters
		// --------------------------------------
		if (WDcfg.DigitizerModel == 5000) {
			Stats.EvInput_cnt[b][ch]++;
			if (EventPHA->Extras != (int16_t)0xAAAA) {
				if (EventPHA->Extras & 0x20) {  // Lost_1K flag
					Stats.EvInput_cnt[b][ch] += 1024;
					Stats.ICRUpdateTime[b][ch] = EventData->TimeStamp;
				}
				if (EventPHA->Extras & 0x04) 
					EventData->Flags |= EVFLAGS_TTRESET;
				if (EventPHA->Extras & 0x08)
					EventData->Flags |= EVFLAGS_FAKE;
				if (EventPHA->Extras & 0x01)
					EventData->Flags |= EVFLAGS_DEADTIME;
				if ((EventPHA->Energy & 0x8000) || (EventPHA->Energy == 0)) {  // pileup
					EventData->Flags |= EVFLAGS_PILEUP;
					Stats.EvPileUp_cnt[b][ch]++;
				}
				if (EventPHA->Extras & 0x10) {
					EventData->Flags |= EVFLAGS_SATUR;
					Stats.Satur_cnt[b][ch]++;
				}
			}
		} else if ((WDcfg.DppType == DPP_PHA_724) || (WDcfg.DppType == DPP_nPHA_724)) {
			if (WDcfg.FWrev >= 67) {
				if (EventPHA->Extras & (1<<6))	{  // flag counting 1024 triggers seen at the input
					Stats.EvInput_cnt[b][ch] += 1024;
					Stats.ICRUpdateTime[b][ch] = EventData->TimeStamp;
				}
				if (EventPHA->Extras & (1<<5))	{  // flag counting 1024 lost triggers
					Stats.EvLost_cnt[b][ch] += 1024;
					Stats.LostTrgUpdateTime[b][ch] = EventData->TimeStamp;
				}
			} else if (WDcfg.FWrev >= 64) {
				Stats.EvInput_cnt[b][ch]++;
				if (EventPHA->Extras & 0x20) {  // Lost_1K flag
					Stats.EvInput_cnt[b][ch] += 1024;
					Stats.ICRUpdateTime[b][ch] = EventData->TimeStamp;
				}
			} else {
				Stats.EvInput_cnt[b][ch]++;
			}
			if (EventPHA->Extras & 0x04) 
				EventData->Flags |= EVFLAGS_TTRESET;
			if (EventPHA->Extras & 0x08)
				EventData->Flags |= EVFLAGS_FAKE;
			if (EventPHA->Extras & 0x01)
				EventData->Flags |= EVFLAGS_DEADTIME;
			if ((EventPHA->Energy & 0x8000) || (EventPHA->Energy == 0)) {  // pileup
				EventData->Flags |= EVFLAGS_PILEUP;
				Stats.EvPileUp_cnt[b][ch]++;
			}
			if (EventPHA->Extras & 0x10) {
				EventData->Flags |= EVFLAGS_SATUR;
				Stats.Satur_cnt[b][ch]++;
			}
		} else {  // DPP_PHA_730
			if (WDcfg.FWrev >= 5) {  // DPP_PHA_730
				if (EventPHA->Extras & (1<<6))	{  // flag counting 1024 triggers seen at the input
					Stats.EvInput_cnt[b][ch] += 1024;
					Stats.ICRUpdateTime[b][ch] = EventData->TimeStamp;
				}
				if (EventPHA->Extras & (1<<5))	{  // flag counting 1024 lost triggers
					Stats.EvLost_cnt[b][ch] += 1024;
					Stats.LostTrgUpdateTime[b][ch] = EventData->TimeStamp;
				}
				if (EventPHA->Extras & (1<<7))
					EventData->Flags |= EVFLAGS_VETOED;
				if (EventPHA->Extras & (1<<8))
					EventData->Flags |= EVFLAGS_UNCORREL;
				if (EventData->Flags & (EVFLAGS_VETOED | EVFLAGS_UNCORREL))
					Stats.EvUncorrel_cnt[b][ch]++;
			} else {
				Stats.EvInput_cnt[b][ch] = -1; // not available
			}
			if (EventPHA->Extras & 0x08)
				EventData->Flags |= EVFLAGS_FAKE;
			if (EventPHA->Extras & 0x01)
				EventData->Flags |= EVFLAGS_DEADTIME;
			if (EventPHA->Energy & 0x8000) {
				EventData->Flags |= EVFLAGS_PILEUP;
				Stats.EvPileUp_cnt[b][ch]++;
			}
			if (EventPHA->Extras & 0x10) {
				EventData->Flags |= EVFLAGS_SATUR;
				Stats.Satur_cnt[b][ch]++;
			}
		}

		// in case of memory full, calculate the busy time
		if (EventData->Flags & EVFLAGS_DEADTIME)
			Stats.BusyTimeGap[b][ch] += (EventData->TimeStamp - Stats.LatestReadTstamp[b][ch]);


		// --------------------------------------
		// PSD
		// --------------------------------------
		EventData->psd = 0; // not available for PHA

		// --------------------------------------
		// Energy
		// --------------------------------------
		if (EventData->Flags & EVFLAGS_TTRESET) {
			EventData->Energy = 0;
		} else if ((EventPHA->Energy & 0x7FFF) == 0x7FFF) { 
			Stats.EvOvf_cnt[b][ch]++;
			EventData->Energy = 0xFFFF;
			EventData->Flags |= EVFLAGS_E_OVR;
		} else if ((EventPHA->Energy == 0) && !(EventData->Flags |= EVFLAGS_PILEUP)) {
			Stats.EvOvf_cnt[b][ch]++;
			EventData->Energy = 0;  // underflow
			EventData->Flags |= EVFLAGS_E_UNR;
		} else {
			EventData->Energy = (EventPHA->Energy & 0x7FFF) / WDcfg.EnergyDiv[b][ch];
		}

		// --------------------------------------
		// Fine Time stamp
		// --------------------------------------
		if ((SysVars.FineTstampMode > 0) && (WDcfg.DppType == DPP_PHA_730)) {
			int16_t ZCneg, ZCpos;
			uint16_t dt = (1  +  WDcfg.CFDinterp[b][ch]*2) * 1000 * WDcfg.Tsampl;  // time interval between the interpolated points (in ps)
			uint16_t zc=0;

			if (extra_sel == 2) {
				EventData->FineTimeStamp = dt * (EventPHA->Extras2 & 0x3FF) / 1024;
			} else {
				ZCneg = (int16_t)(EventPHA->Extras2 & 0xFFFF);
				ZCpos = (int16_t)((EventPHA->Extras2 >> 16) & 0xFFFF);
				if ((ZCneg < 0) && (ZCpos >= 0))
					zc = dt * ZCpos / (ZCpos - ZCneg);  // fine tstamp is expressed in ps
				EventData->FineTimeStamp = zc;
			}
		} else {
			EventData->FineTimeStamp = 0;
		}

		// --------------------------------------
		// Waveforms
		// --------------------------------------
		if ((EventPHA->Waveforms != NULL) && (Wfm != NULL)) {
			CAEN_DGTZ_DecodeDPPWaveforms(handle[b], EventPHA, WaveformPHA);
			Wfm->Ns = WaveformPHA->Ns;
			Wfm->DualTrace = WaveformPHA->DualTrace;

			if (Wfm->TraceSet[0] == 3) {
				for(i=0; i<Wfm->Ns; i++) 
					Wfm->AnalogTrace[0][i] = WaveformPHA->Trace1[i]/2;
			} else {
				memcpy(Wfm->AnalogTrace[0], WaveformPHA->Trace1, Wfm->Ns * sizeof(uint16_t));
			}
			//memcpy(Wfm->AnalogTrace[0], WaveformPHA->Trace1, Wfm->Ns * sizeof(uint16_t));

			if (WDcfg.WaveformProcessor) {
				SW_WaveformProcessor(b, ch, Wfm->Ns, (uint16_t *)WaveformPHA->Trace1, EventData, Wfm->AnalogTrace[1], Wfm->DigitalTraces);
			} else if (Wfm->DualTrace) {
				if ((Wfm->TraceSet[1] == 2) || (Wfm->TraceSet[1] == 3)) {
					for(i=0; i<Wfm->Ns; i++) 
						Wfm->AnalogTrace[1][i] = WaveformPHA->Trace2[i]/2;
				} else {
					memcpy(Wfm->AnalogTrace[1], WaveformPHA->Trace2, Wfm->Ns * sizeof(uint16_t));
				}
				//memcpy(Wfm->AnalogTrace[1], WaveformPHA->Trace2, Wfm->Ns * sizeof(uint16_t));
			}

			for(i=0; i<Wfm->Ns; i++) 
				Wfm->DigitalTraces[i] = WaveformPHA->DTrace1[i] | (WaveformPHA->DTrace2[i] << 1);
			EventData->Waveforms = Wfm;
		}

	// ##########################################################################################
	// STD_FW
	// ##########################################################################################
	} else if (IS_STD_FW(WDcfg.DppType)) {
		memset(EventData, 0, sizeof(GenericDPPEvent_t)); // most of the fields are zero
		EventData->TimeStamp = (uint64_t)(*(uint32_t *)Event);
		if (WDcfg.WaveformProcessor)
			SW_WaveformProcessor(b, ch, Wfm->Ns, Wfm->AnalogTrace[0], EventData, Wfm->AnalogTrace[1], Wfm->DigitalTraces);
		EventData->Waveforms = Wfm;
	}

	return 0;
}


